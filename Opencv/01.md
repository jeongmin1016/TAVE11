# 1주차 요약본

# Chapter2. OpenCV로 시작하는 컴퓨터 비전

## 2.1 OpenCV 소개

OpenCV : 인텔 사에서 만든 컴퓨터 비전 라이브러리, C와 C++로 개발됨

- 교차플랫폼을 사용하기 때문에 개발한 프로그램을 어떤 운영체 플랫폼에서도 사용 가능

## 2.3 객체지향 잘 활용하기

객체지향의 특성

- 객체 능동적 : .을 찍어 자신이 가진 함수(method, 멤버변수 포함) 능동적 호출
- 필요한 만큼 찍어내기 : 클래스로 객체 무한정 생성

```python
import numpy as np

a=np.array([4,5,0,1,2,3,6,7,8,9,10,11])

print(a)
print(type(a)) # 객체가 어떤 클래스인지 확인  
print(dir(a)) # 사용가능한 멤버 함수 목록

# 멤버함수 적용
print(a.shape)
a.sort()
print(a)
```

**help** : 멤버 함수가 무슨 일을 하며 어떻게 사용되는지 알기 위함

ex) help(a.sort)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/55d3bda1-b134-46bf-b532-c6ea8926498b/Untitled.png)

## 2.4 영상을 읽고 표시하기

```python
import cv2 as cv
import sys

img = cv.imread("glory.jpg") # 영상읽기

if img is None:
  sys.exit("파일을 찾을 수 없습니다.") 

cv.imshow("Image Display", img) # 윈도우에 영상표시

cv.waitKey() # 키 입력대기시간 ms
cv.destroyAllWindows() # 윈도우 창 종료 함수
```

- if 구문 역할 : 파일이 없거나 읽는 도중 오류 발생시 img None
- imshow : 윈도우에 영상표시 역할 (윈도우 이름, 디스플레이할 영상)
- waitKey : 키가 눌리면 해당 키의 유니코드 값 반환, 기본값으로 없거나 0
    - 지정시간 내에 키 입력이 일어나지 않으면 -1 반환하며 아래로 나려가 윈도우 종료
    - destroyAllWindows : 키 입력 대기하다가 윈도우 닫고 정상적으로 프로그램 종료

### 오류 해결 방법

- colab :
    
    cv2.imshow() is disabled in Colab, because it causes Jupyter sessions
    
    코랩에서 위 옵션이 비활성화
    
    google colab 자체 개발 라이브러리 적용
    
    from google.colab.patches import cv2_imshow
    
- jupyter : !pip install opencv-python 로 오류해결

### np 클래스형 객체

- np는 다차원 배열을 위한 표준 모듈이기에 사용
- 3차원 배열, 색 표현 **BGR**
    - 색상을 표현하는 방법으로는 RGB(Red, Green, Blue) 방식. 빨강, 초록, 파랑 세 가지 색의 빛을 섞어서 원하는 색 형성.
    - 각 색상은 0~255 사이의 값으로 표시하고 값이 커질수록 해당 색상의 빛이 밝아지는 원리
    - RGB = (255, 255, 255) 일 때는 흰색이고, RGB = (0, 0, 0) 일 때는 검정.
    - 그러나 **OpenCV는 그 반대의 순서인 BGR로 표현합니다**
        
        [OpenCV - 7. 이미지 색상 표현 방식(BGR, HSV, YUV) (tistory.com)](https://bkshin.tistory.com/entry/OpenCV-7-%E3%85%87%E3%85%87)
        

```python
print(img[0,0,0], img[0,0,1], img[0,0,2]) # (0,0) 화소 조사
print(img[0,1,0], img[0,1,1], img[0,1,2]) # (0,1) 화소 조사
```

화소(픽셀)은 좌표로 표기하며 영상을 구성하는 한 점

좌표(BGR)이 색깔을 의미 

## 2.5 영상 형태 변환 & 크기 축소

```python
import cv2 as cv
import sys

img = cv.imread("glory.jpg") # 영상읽기

if img is None:
  sys.exit("파일을 찾을 수 없습니다.") 

gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY) # BGR 컬러 영상을 명암 영상으로 변환
gray_small=cv.resize(gray,dsize=(0,0),fx=0.5,fy=0.5) # 반으로 축소

cv.imwrite("glory_gray.jpg",gray) # 영상을 파일에 저장
cv.imwrite("glory_gray_small.jpg",gray_small)

# 윈도우에 영상표시 : 영상 3개를 서로 다른 윈도우 3개에 디스플레이

cv.imshow('Color image',img)
cv.imshow('Gray image',gray)
cv.imshow('Gray image small',gray_small)

cv.waitKey()
cv.destroyAllWindows()
```

- cvtColor : 컬러영상을 명암영상으로 변환
    
    ![[Opencv 컬러 이미지 Gray 변환(cvtColor 함수) : 네이버 블로그 (naver.com)](https://m.blog.naver.com/ezpr2st/221909507609)](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/12ded513-dd6d-4ea3-a198-3eec110a3477/Untitled.png)
    
    [Opencv 컬러 이미지 Gray 변환(cvtColor 함수) : 네이버 블로그 (naver.com)](https://m.blog.naver.com/ezpr2st/221909507609)
    
    - 컬러기반 RGB를 명암영상으로 변환후, round 함수를 이용해 반올림
    - 이러한 연산을 모든 화소에 적용하면 명암 영상 생성
    
- resize : 크기변환 (입력영상, 변환할 크기지정, 가로, 세로 비율)

+) 영상의 확장자를 변경하고 싶다면, imwrite에서 변경해 파일 저장 

ex.  glory_gray.jpg → glory_gray.png

## 2.6 웹 캠에서 비디오 읽기

```python
import cv2 as cv
import sys

cap = cv.VideoCapture(0,cv.CAP_DSHOW) # 카메라와 연결시도

if not cap.isOpened():
  sys.exit("카메라 연결 실패")

while True:
  ret,frame=cap.read() # 비디오 구성하는 프레임 획득 

  if not ret:
    print("프레임 획득에 실패하여 루프를 나갑니다.")
    break

  cv.imshow("Video display", frame)

  key = cv.waitKey(1) # 1밀리초 동안 키보드 입력 기다림
  if key==ord('q'): # 'q'키가 돌아오면 루프 아웃
    break

cap.release() # 카메라와 연결 끊음
cv.destroyAllWindows() # 윈도우 모두 닫음
```

+) 웹캠 사용이 안되는 이유 : 

윈도우 기본 카메라 앱에서는 출력되지만, opencv에서 특정 웹캠 연결 문제가 발생하여 영상이 출력되지 않는 경우가 가끔 발생합니다. 다양한 이유가 있지만, 동영상 프레임을 불러오는 과정을 결정짓는 **apiPreference 문제** 로 발생하기도 합니다.

[[Python] OpenCV 웹캠 연결 문제 cv2.VideoCapture 해결 방법 #1 (tistory.com)](https://deep-eye.tistory.com/73)

- VideoCapture : 웹캠과 연결 시도 (웹 캠 번호, 비디오 화면 보임)

- 웹캠 연결 여부 확인 : 실패시 isOpened 함수가 fail값을 보유하게 됨
    
    
- 동영상 입력하는 방법
    - 사용자가 q 누르면 루프 out
    - read : 호출한 순간의 영상 한 장, 프레임 획득 및 성공 여부와 함께 프레임 반환
        - ret : 성공여부
        - frame : 프레임 저장
    - Video display : 윈도우에 획득한 영상 디스플레이
    
- waitKey : 인수를 크게 설정해 기다리는 시간이 길어지면 지연 발생
    
    → 비디오 매끄럽지 않게 나타나는 부작용 발생 
    

### 비디오에서 수집한 영상 이어붙이기

```python
import cv2 as cv
import numpy as np
import sys

cap=cv.VideoCapture(0,cv.CAP_DSHOW) # 카메라와 연결 시도

if not cap.isOpened():
	sys.exit('카메라 연결 실패')

frames=[]
while True:
  ret,frame = cap.read() # 비디오를 구성하는 프레임 획득

  if not ret:
	  print('프레임 획득에 실패하여 루프를 나갑니다.')
	  break

  cv.imshow("Video display", frame)

  key = cv.waitKey(1) # 1밀리초 동안 키보드 입력 기다림
  if key==ord('c'): # 'C' 키가 들어오면 프레임을 리스트에 추가
	  frames.append(frame) #'q'키가 들어오면 루프를 빠져나감
  elif key==ord('q'):
	  break

cap.release() # 카메라와 연결을 끊음
cv.destroyAllWindows()

if len(frames)>0: # 수집된 영상이 있으면
  imgs=frames[0]
  for i in range(1,min(3, len(frames))): # 최대 3개까지 이어 붙임.
	  imgs=np.hstack((imgs, frames[i]))

  cv.imshow("collected images',imgs")
	
  cv.waitKey()
  cv.destroyAllWindows()
```

frames=[]

수집한 영상을 저장할 리스트 생성

if key==ord('c'): # 'C' 키가 들어오면 프레임을 리스트에 추가
	  frames.append(frame) 

사용자가 c를 누를 때마다 획득한 프레임을 리스트 추가

if len(frames)>0: # 수집된 영상이 있으면
  imgs=frames[0]
  for i in range(1,min(3, len(frames))): # 최대 3개까지 이어 붙임.
	  imgs=np.hstack((imgs, frames[i]))

  cv.imshow("collected images',imgs")
	
  cv.waitKey()
  cv.destroyAllWindows()

- hstack : 배열을 이어 붙이는 함수

수집한 영상을 이어 붙여 윈도우에 표시하며 최대 세개 붙이기 

한정적인 이유 : 영상이 너무 커서 화면 밖으로 나가는 것 방지를 위함

ex 8번 눌러도 세번 반복해 배열 3개 붙임

frame리스트와 imgs 배열로 영상의 특성 확인

→ type과 shape 잘 이해하기

## 2.7 그래픽 기능과 사용지 인터페이스 만들기

line 직선그리기  
rectangle 직사각형 그리기  
polylines 다각형 그리기  
circle 원 그리기  
elipse 타원 그리기 
putText 문자열 작성

### 직사각형 그리기

```python
cv.rectangle(img,(830,30),(1000,200),(0,0,255),2)
```

직사각형 그릴 영상, 직사각형의 왼쪽 위 구석점 좌표, 오른쪽 아래 구석점 좌표, 색지정(BGR), 선두께

### 문자열 작성

```python
cv.putText(img,'laugh',(830,24),cv.FONT_HERSHEY_SIMPLEX,1,(255,0,0),2)
```

영상, 문자열, 문자열의 왼쪽 아래 구석점 위치 지정, 폰트 종류, 글자 크기, 색, 글자 두께

### 마우스를 통한 상호작용

```python
import cv2 as cv
import sys

img = cv.imread("glory.jpg") # 영상읽기

if img is None:
  sys.exit("파일을 찾을 수 없습니다.")

def draw(event,x,y,flags,param): # 콜백 함수
  if event==cv.EVENT_LBUTTONDOWN:# 마우스 왼쪽 버튼 클릭했을 때 
    cv.rectangle(img,(x,y),(x+200,y+200),(0,0,255),2)
  elif event==cv.EVENT_RBUTTONDOWN: # 마우스 오른쪽 버튼 클릭
    cv.rectangle(img,(x,y),(x+100,y+100),(255,0,0),2)

  cv.imshow("Drawing",img)

cv.namedWindow("Drawing")
cv.imshow("Drawing",img)

cv,setMouseCallback('Drawing',draw) # drawing 윈도우에 draw 콜백 함수 지정

while(True): # 마우스 이벤트가 언제 발생할지 모르기 때문에 무한 반복
  if cv.waitKey(1)==ord('q'):
    cv.destriyAllWindows()
    break
```

# Chapter3. 영상 처리

## 3.1 디지털 영상 기초

디지털 카메라는 실제 세상에 존재하는 피사체 일정한 간격 샘플링하고 명암을 일정한 간격으로 양자화하는 과정을 통해 디지털 영상 획득

### 핀홀 카메라와 디지털 변환

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9b212e0a-4054-481f-86e3-5eb3d12a0c15/Untitled.png)

카메라가 영상 획득하는 과정이 핀홀 카메라 모델은 핵심 설명

- 물체에 반사된 빛은 작은 구멍을 통해 안으로 들어감
- 이 빛은 영상 평면에 맺힘
- 빛이라는 아날로그 신호를 받은 영상 평면(OCC센서) 는 **디지털 신호**로 변환한 영상을 메모리에 저장
    - 디지털로 변환하는 과정에서 샘플링과 양자화 수행
    - 샘플링 : 2차원 영상 공간을 가로 방향 N개 세로방향 M개 구간으로 나눔
        
        → 이러한 점을 화소(픽셀), M x N을 영상 크기 또는 해상도
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1715e860-dac5-4836-bc5d-bdeca3effbe5/Untitled.png)
        

### 영상 좌표계

영상은 2차원 좌표계 

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/040f2f48-aa21-422b-a64d-ce318e8698fc/Untitled.png)

1. 원점*(0,0)*이 좌측 상단
    
    x축 *0, 1, … , N-1*로 정수 좌표를 가짐
    
    y축 *0, 1, … , M-1*의 정수 좌표를 가짐
    
2. *(y,x)* 표기 
    
    행 좌표 먼저, 열 좌표 그 다음
    
    → 디지털 영상은 2차원 배열에 저장되기 때문에 이 관행 따름
    
    영상을 저장하는 배열에서 화소의 위치 지정할 때 사용하나 그 외엔 주로 *(x,y)*
    

## 3.1.2 다양한 종류의 영상

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/092e9ddd-fdf8-4eb5-a8a5-7e7bf5f2dece/Untitled.png)

### 물체가 반사한 빛을 측정한 디지털 영상

1. **명암영상**은 채널이 하나이며 2차원 배열 구조
2. RGB는 **3개 채널 컬러 영상**으로 3차원 구조의 배열 표현
3. **웹캠** **컬러 동영상**은 4차원 구조 배열
4. 3차원 구조의 배열과 다채널
    
    **다분광 영상**으로 3-10개의 채널 존재하며 자외선과 적외선 영역까지 확장한 형태
    
    **초분광영상**은 조밀하게 획득한 수백 수천개의 채널 존재
    
    의료에서 사용되는 MR, CT도 동일
    

### 물체까지 거리를 측정한 영상

  e. **RGB-D영상**(RGB 컬러 센서와 깊이 센서가 통합된 카메라로 획득)

  f. 라이다라는 깊이센서로 확인했을 시, 어떤 조건을 만족하는 점의 거리만 측정하기 때문에, 완벽한 격자 구조가 아니기에 획득한 거리 데이터를 보여주는 **점구름영상** 

## 3.1.3 컬러 모델

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/56e1c958-580a-4ce4-b4b7-91dca9abed0e/Untitled.png)

1. RGB 삼원색을 사용하면 모든 색 표현 가능
2. 세 요소의 범위를 0-1로 설정해 세상의 모든 색을 큐브에 삽입
    
    R (1,0,0) G (0,1,0) B (0,0,1)
    
3. b인 RGB 큐브를 디지털 영상으로 표현할 때 각 요소를 양자화

## 3.1.4 RGB 채널별로 디스플레이

np가 지원하는 **ndarray 클래스**로 표현

RGB 영상의 일부를 잘라내고 R G B 채널로 분리하기 위해 numpy 배열 다루는 연습

```python
import cv2 as cv
import sys

img = cv.imread("glory.jpg") # 영상읽기

if img is None:
  sys.exit("파일을 찾을 수 없습니다.")

# 세 채널을 가진 원래 이미지 img 디스플레이
cv.imshow("original_RGB",img) 
# img 왼쪽 위 컷컷
cv.imshow("Upper left half",img[0:img.shape[0]//2,0:img.shape[1]//2,:])
# img 첫번째와 두번째 축을 1/4~3/4 지정해 영상의 중간 부분 컷
cv.imshow("Center half",img[img.shape[0]//4,3*img.shape[0]//4,img.shape[1]//4:3*img.shape[1]//4,:])

cv.imshow("R channel",img[:,:,2])
cv.imshow("R channel",img[:,:,1])
cv.imshow("R channel",img[:,:,0])

cv.waitKey()
cv.destroyAllWindows()
```

# 3.2 이진 영상

이진영상 : 0 또는 1의 흑백 영상 

→ 프로그래밍 편리성 우선시

## 3.2.1 이진화

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/47bb5a5c-5cfa-4884-9f2d-317d38d90779/Untitled.png)

f 는 원래 명암 영상 b는 이진영상으로 위 식은 이진화하는 함수

임계값 T의 결정이 중요 

- 너무 낮게 또는 높게 설정 시, 대부부분 화소가 물체또는 배경에 쏠리는 문제 발생
    
    → 해결 : 히스토그램의 계곡 근처를 임곗값으로 결정해 쏠림현상 누구러뜨림 
    

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9f5f56f4-38ba-4392-bfdf-7466a6d4b648/Untitled.png)

임계값 T = 4로 계곡이 발생해 이진화에 따라 다음과 같이 이진영상 표현

```python
import cv2 as cv 
import matplotlib.pyplot as plt

img = cv.imread("glory.jpg") # 영상읽기
h = cv.calcHist([img],[2],None,[256],[0,256]) # 2번 채널에서 히스토그램 
plt.plot(h,color='r',linewidth=1)
```

실행 결과를 확인해보면 큰 계곡3, 작은 계곡 아주 많음

→ 계곡 값으로 정하기 어려움

## 3.2.2 오츄 알고리즘

**점연산 해당 ↔ 모폴로지 : 영역 연산**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aa1a67c8-0895-4315-8e41-c254c08d10f5/Untitled.png)

**오츄알고리즘**은 위에서 본 계곡값으로 임곗값을 정하는 것에 어려움이 있어 **이진화 최적화**로 가능

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2bf1f012-f7f0-4a11-a4c7-969a607b57bf/Untitled.png)

- J 목적함수
    - t의 좋은 정도를 측정하는 데 작을수록 좋음
- 매개 변수 t : 해 공간 구성
- t 햇 : J가 최소인 명암값을 최적값

→ t 햇을 임계값으로 사용해 이진화

```python
import cv2 as cv
import sys

img = cv.imread("glory.jpg") # 영상읽기

t,bin_img = cv.threshold(img[:,:,2],0,255,cv.THRESH_BINARY+cv.THRESH_OTSU)
print("오츄 알고리즘이 찾은 최적 임계값=", t)

cv.imshow("R channel",img[:,:,2]) # R 채널 영상
cv.imshow("R channel binarization",bin_img) # R 채널 이진화 영상

cv.waitKey()
cv.destroyAllWindows()
```

cv.THRESH_BINARY+cv.THRESH_OTSU : 오츄 알고리즘으로 이진화 수행

threshold 함수는 알고리즘이 찾은 최적의 임계값과 이진화된 영상 반환

[:, :, 2] = [B, G, R] 이기 때문에 위의 결과는 R채널로 이진화 

+) 오츄알고리즘 말고도 낱낱 탐색 알고리즘(모든 해 검사), 탐욕 알고리즘, 역전파 알고리즘 존재

## 3.2.3 연결 요소

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bf9c0dcd-139e-4629-8fc7-95f2b31d4c35/Untitled.png)

연결 요소 : 1의 값을 진 연결된 화소의 집합 → opencv에서 connectedComponents 함수로 탐색

- 고유한 정수 번호 구분

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/428fdbb0-84a9-4cea-85e1-e0c18a42f9cb/Untitled.png)

이해가..

## 3.2.4 모폴로지

목적 : 영상을 변환하는 과정에서 하나의 물체가 **여러 영역으로 분리**되거나 다른 물체가 **한 영역으로 붙는 현상** 발생을 최소화하기 위함

모폴로지 : 구조요소를 이용해 영역의 모양 조작

모폴로지는 이진과 명암으로 나뉜다

- 회색이 중심화

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8909895b-aba0-49da-96cc-55da58c4f4a8/Untitled.png)

구조 요소 모양에 달려 있는 팽창과 침식

- 팽창 : 구조 요소의 중심을 1인 화소에 씌운 다음 구조 요소에 해당하는 모든 화소 1로 변경
- 침식 : 구조 요소의 중심을 1인 화소 p에 씌운 다음
    - 구조 요소에 해당하는 모든 화소가 1에 해당 O : p를 1로 유지
    - 구조 요소에 해당하는 모든 화소가 1에 해당 X  : p = 0
- 닫힘 : 침식 결과 + 팽창 적용
- 닫힘 : 팽창 결과 + 침식 적용

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7cdb36e5-ea0b-44d2-a4c9-98d2e0963572/Untitled.png)

### 모폴로지 연산

[히스토그램부터 모폴로지까지 - NiklasJang’s Blog](https://niklasjang.github.io/opencv/opencv-chapter-2/#:~:text=%EC%A0%90%20%EC%97%B0%EC%82%B0%20%3A%20%ED%99%94%EC%86%8C%EA%B0%80%20%EC%9E%90%EC%8B%A0%EC%9D%98%20%EA%B0%92%EB%A7%8C%EC%9D%84%20%EB%B3%B4%EA%B3%A0%20%EC%83%88%EB%A1%9C%EC%9A%B4,%EA%B8%B0%ED%95%98%ED%95%98%EC%A0%81%20%EA%B7%9C%EC%B9%99%EC%97%90%20%EB%94%B0%EB%9D%BC%20%EB%8B%A4%EB%A5%B8%20%EA%B3%B3%EC%97%90%20%EC%9E%88%EB%8A%94%20%EA%B0%92%EC%9D%84%20%EC%B7%A8%ED%95%9C%EB%8B%A4.)

- 점 연산 : 화소가 자신의 값만을 보고 새로운 값을 정한다.
- 영역 연산 : 화소가 이웃에 있는 몇 개의 화소들을 보고 새로운 값을 정한다.
- 기하 연산 : 일정한 기하하적 규칙에 따라 다른 곳에 있는 값을 취한다.

# 3.3 점 연산

오츄이진화를 제외한 다른 점연산 소개

## 3.3.1 명암 조절

수식을 이용해 영상을 밝게 어둡게 조정 가능하게 하는 선형연산

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e06f31fb-7741-4b03-8866-9e44812a0407/Untitled.png)

1. 원래 영상에 양수를 더해 밝게
2. 원래 영상에 양수를 더해 어둡게 
3. 원래 명암값을 빼서 반전

### **감마조정**

명암 10 → 20 과 100 → 110 같은 만큼 향상했지만 인간이 느끼는 정도가 다름 

위에 대해 **비선형적인 시각 반응을 수학적으로 표현**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ed8db2c8-0120-452a-864f-8bf017fb712e/Untitled.png)

정규화환 영상 

감마는 사용자가 조정하는 값

1이면 원래 영상 유지, 1보다 작으면 밝음, 크면 어두움

```python
def gamma(f, gamma=1.0): # (감마 보정 영상, 감마=기본값)
  f11 = f/255.0 # L = 256 가정 -> 정규화 과정
  return np.unit8(255*(f1**gamma))
 
# 영상 종류별로 확인
gc = np.hstack((gamma(img,0.5),gamma(img,0.75),gamma(img,1.0),gamma(img,2.0),gamma(img,3.0)))
cv.imshow('gamma',gc)
```

## 3.3.2 히스토그램 평활화

히스토그램이 평평하게 되도록 영상을 조작해 영상의 명암 대비를 높이는 기법
→ 명암대비 높아지면 물체 더 잘 식별

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9d91c3a6-03fd-4231-a6c8-3058de48cb19/Untitled.png)

- 정규화 히스토그램 h 점 :모든 칸의 값을 합해 1.0이 되는 정규화 히스토그램
- 누적 정규화 히스토그램 h 점점 : i번째 칸은 0부터 i까지 합한 값을 가진 것
- l : 원래 명암값
- l’ : 평활화로 얻은 새로운 명암값

# 3.4 영역 연산

## 3.4.1 컨볼루션 (convolution)

컨볼루션 : 입력 영상 f의 각 화소에 필터를 적용해 곱의 합 구하는 연산

입력영상 f 와 필터 u 의 컨볼류션의 결과 출력영상 f’

→ 필터의 픽셀 value의 index는 -1 0 1

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/de7e3e77-225f-4081-b7d7-fe5e7f2a83be/Untitled.png)

1차원 필터 적용 

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ccb45cb0-0b1c-46e3-aa78-5ad41289ce09/Untitled.png)

2차원 필터 적용

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cf134ea5-4600-455d-b91d-190d1ad76882/Untitled.png)

- 적용결과, 필터를 가장자리 화소에 적용하면 일부가 밖으로 나가, 적용 어려움
    
    → f’의 가장자리를 -로 표시
    
- 결과는 별도의 출력 영상 f’ 에 기록

## 3.4.2 다양한 필터

특정한 목적없는 일반 연산이며 **필터 결정시 목적 결정**

### 스무딩 필터

영상에 존재하는 다양한 잡음은 밝은 영역에 어두운 작은 반점이 여기 저기 나타남

스무딩 필터로 컨볼루션하면 이를 저하할 수 있음 

↔ 단점 

부작용으로 물체의 경계를 흐릿하게 만드는 **블러링** 

### 샤프닝 필터

스무딩과 반대로, 엣지를 선명하게 해 물체의 식별 도움 

↔ 단점 

잡음 확대 

# 3.5 기하 연산

앞에서 다룬 연산들은 자기 자신 혹은 이웃을 보고 값을 정했으나, 이번엔 머리있는 화소에서 값을 가져올 수 있는 연산 

→ 영상의 크기를 조절하거나 영상회전 가능

## 3.5.1 동차 좌표와 동차 행렬

점 (x,y)는 동차 점(xt, yt, t)가 존재하는 데 t는 임의의 숫자

- 2차원 점의 위치에 1을 임의로 추가해 3차원 벡터로 표현한 것 = (x,y,1)
    
    → 변환이 자유로워 사용하는 듯?
    
- 동차 좌표에서는 3개 요소에 같은 값을 곱하면 같은 좌표를 나타낸다
    
    (-3, 6,1), (-2,4,1) (-1,2,5,0) 모두 점 (-2,4)에 해당
    
    → 따라서 네개의 점이 모두 점 (-2,4)의 가능한 동차 좌표들
    

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fcf5f8cd-c457-4ddc-a861-8b6fb10213a8/Untitled.png)

수학표기가 깔끔하며 계산 효율이 좋음 

→ 행렬 계산 을 할때 큰 이점

## 3.5.2 영상의 기하 변환

앞서 배운  동차 변환을 적용 가능 ; 회전하거나 크기를 조정할 수 있음 

원래 영상을 동차 행렬을 이용해 새로운 영상으로 변환하는 과정에서 에러 발생

### 에일리어싱(aliasing) :

실수 좌표를 정수로 반올림할 시, 결측값으로 표시된 화소처럼 값을 받지 못하는 경우 발생

방지하기 위해, 원래 영상의 해당화소를 찾는 후방변환 사용(동차행렬 A의 역행렬)

↔ 안티 에일리어싱 : 에일리어싱 저하 

## 3.5.3영상 보간

실수 좌표를 정수로 변환하는 과정 필요

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/19428859-1682-45bd-a016-9e660e9b9aae/Untitled.png)

최근접 이웃방법(=영상보간) : 반올림을 사용해 가장 가까운 화소에 배정하는 기법

- 겹치는 비율을 곱하기 때문에 선형 보간법에 해당

# 3.6 OpenCV의 시간 효율
